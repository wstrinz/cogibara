#!/usr/bin/env ruby
require 'cogibara'
require 'slop'
require 'redis'

class Listener

  def record(duration, threshold=0.1)
    z = `arecord -f cd -d #{duration}`
    f = File.open('record.wav','wb'){|fi| fi.write z}
    volume = `sox record.wav -n "stats" 2>&1`.scan(/Max level.*\n/).first.chomp.gsub("Max level","").strip.to_f
    `rm record.wav`
    volume > threshold ? z : nil
  end

  def speak(message)
    # engine = Cogibara::config.speech_engine
    # voice = Cogibara::config.voice
    engine = :pico

    if engine == :pico
      `pico2wave -w speech.wav "#{message}"`
      `aplay speech.wav`
      `rm speech.wav`
    elsif engine == :festival
      `echo #{message} | text2wave | aplay`
    else
      `espeak #{message}`
    end
  end

  def sleep_mode
    loop do
      puts "sleeping"
      audio = nil
      until audio
        audio = record(3,0.3)
      end
      begin
        @transcriber.transcribe(audio)
        return
      rescue

      end
    end
  end

  def get_message(tries=3)
    #should play a sound
    puts "listening!"
    loop do
      audio = record(@basedur)
      audio = record(@basedur) unless audio

      unless audio
        sleep_mode 
      else
        #play a sound as well
        puts "Processing"

        msg = nil
        begin
          msg = @transcriber.transcribe(audio)
          return msg
        rescue Exception
          puts "failed to transcribe  (#{$!})"
        end
      end
    end
    speak("Sorry, I couldn't understand you")
  end

  def ask_once
    message = get_message
    puts message
    answer = ""
    if message
      answer = Cogibara::message_handler.handle(message)
    end
    speak(answer)
    answer
  end

  def initialize
    @transcriber = Cogibara::Transcriber.new

    @basedur = 8
  end

  def ask_loop
    loop do
      puts ask_once
    end
  end

end

def text(msg)
  Cogibara::message_handler.handle(msg)
end


def text_loop
  loop do
    text $stdin.gets
  end
end

def text_or_file
  puts @config_file
  if !@config_file && File.exist?("./#{@msg}")
    Cogibara::file_handler.handle(File.open("./#{ARGV[0]}",'rb').read, "local")
  else
    text(@msg)
  end
end

def parse

  opts = Slop.parse do
    on 'v', 'verbose', 'Verbose output'
    on 'm=', 'message', 'Message'
    on 'n=', 'name', 'Name'
    on 'c=', 'config', 'Configuration file (.rb)'
    on 'r', 'redis', 'Standalone Redis mode'
    on 'a', 'audio', 'Audio mode (uses microphone)'
    on 'la', 'looped-audio', 'Looped Audio mode'
  end

  @verbose = opts.verbose?
  @msg = opts[:message]
  @name = opts[:name] || "cogibara"
  @config_file = opts[:config]
  @redis_mode = opts[:redis]
  @audio = opts[:audio]
  @looped_audio = !@audio && opts[:looped_audio]

  if !@msg
    if @config_file
      @verbose = false
    else
      @msg = ARGV.join(' ')
      if File.exist?("./#{@msg}")
        ext = @msg.to_s.split('.').last
        @config_file = @msg if %w(yml rb).include? ext
      end
      @verbose = false
    end
  end
end

def configure
  if @config_file
    ext = @config_file.to_s.split('.').last
    if ext == 'yml'
      Cogibara::dispatcher.config_from_yaml(@config_file.to_s)
    else
      load './' + @config_file.to_s 
    end
  else
    Cogibara.default_config
  end
  Cogibara.setup do |config|
    config.name = @name unless @name.nil?
    config.local = true
    config.use_redis = false
    config.verbose = @verbose unless @verbose.nil?
  end
end

def standalone_redis
  Cogibara::config.use_redis = true
  @red = Redis.new
  Redis.new.subscribe(:toCapy) do |on|
    on.message do |channel, msg|
      file = @red.hmget("#{msg}",'file')
      text = @red.hmget("#{msg}",'text')
      client = @red.hmget("#{msg}",'client')[0].to_i
      puts "message from #{client}"
      if file[0]
        puts "Handling as file "
        begin
          Cogibara::FileHandler.new.handle(file[0], client)
        rescue Exception
          puts "an error occured! " + ($!).to_s
        end
      elsif text[0]
        puts "Handling as text"
          Cogibara::message_handler.handle(Cogibara::Message.new(text[0],client))
      end
    end
  end
end

parse

configure

standalone_redis if @redis_mode

if @audio
  Listener.new.ask_once
elsif @looped_audio
  Listener.new.ask_loop if @looped_audio
elsif ARGV[0] && (@msg != @config_file)
  text_or_file
else
  text_loop
end
